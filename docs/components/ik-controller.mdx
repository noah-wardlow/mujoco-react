---
title: "IkController"
description: "Opt-in inverse kinematics controller plugin"
icon: "robot"
---

A composable IK controller built with the `createController` factory. Wraps children with IK context so components like `<IkGizmo>` can access IK state.

IK is **not baked into the core** â€” it's an opt-in plugin you add to your scene tree when you need it.

## Usage

```tsx
import { IkController, IkGizmo } from 'mujoco-react';

<MujocoCanvas config={config}>
  <IkController config={{ siteName: 'tcp', numJoints: 7 }}>
    <IkGizmo />
  </IkController>
</MujocoCanvas>
```

### With Custom Solver

```tsx
import type { IKSolveFn } from 'mujoco-react';

const myIK: IKSolveFn = (pos, quat, currentQ) => {
  return myAnalyticalSolver(pos, currentQ);
};

<IkController config={{ siteName: 'tcp', numJoints: 7, ikSolveFn: myIK }}>
  <IkGizmo />
</IkController>
```

## Config

<ParamField body="siteName" type="string" required>
  MuJoCo site to track and solve IK towards.
</ParamField>

<ParamField body="numJoints" type="number" required>
  Number of joints for the IK solver.
</ParamField>

<ParamField body="ikSolveFn" type="IKSolveFn">
  Custom IK solver function. When provided, replaces the built-in Damped Least-Squares solver.
  Signature: `(pos: Vector3, quat: Quaternion, currentQ: number[]) => number[] | null`
</ParamField>

<ParamField body="damping" type="number" default="0.01">
  DLS damping parameter. Lower values give faster convergence but may oscillate.
</ParamField>

<ParamField body="maxIterations" type="number" default="50">
  Maximum solver iterations per physics frame.
</ParamField>

## Accessing IK State

Use the `useIk()` hook from any descendant of `<IkController>`:

```tsx
import { useIk } from 'mujoco-react';

function MyComponent() {
  const { setIkEnabled, moveTarget, solveIK, getGizmoStats } = useIk();

  // Enable IK
  setIkEnabled(true);

  // Animate target to a position over 500ms
  moveTarget(new THREE.Vector3(0.5, 0, 0.3), 500);

  // Snap gizmo to current site position
  syncTargetToSite();

  // Solve IK manually
  const solution = solveIK(targetPos, targetQuat, currentJoints);
}
```

For components that may or may not be inside an `<IkController>`, use `{ optional: true }`:

```tsx
const ikCtx = useIk({ optional: true });
// Returns null if no IkController ancestor
```

## Built-in Solver Details

The default solver uses **Damped Least-Squares** (DLS) with finite-difference Jacobian:

- **Position weight**: 1.0
- **Rotation weight**: 0.3
- **Tolerance**: 1e-3
- **Method**: Finite-difference Jacobian + pseudoinverse

The solver tracks the best solution across iterations and returns it even if tolerance isn't reached. It works for any MuJoCo model without robot-specific parameters.

## Reset Behavior

When the simulation is reset (via `api.reset()`, `api.applyKeyframe()`, or `api.loadScene()`), the IkController automatically:
- Syncs the gizmo to the current site position
- Stops any in-progress gizmo animation
- Disables IK solving

## Notes

- Must be a child of `<MujocoCanvas>`
- `<IkGizmo>` must be a descendant of `<IkController>` (not a sibling)
- Multiple `<IkController>` instances can coexist for multi-arm setups
- The IK solver runs inside `useBeforePhysicsStep`, writing to `data.ctrl`
