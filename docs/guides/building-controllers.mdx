---
title: "Building Controllers"
description: "Write your own controller, bring your own IK — compose library hooks into robot-specific logic"
icon: "gamepad"
---

**Controllers are just React components.** There's no base class to extend, no interface to implement, and no registration step. A controller is any component that calls `useBeforePhysicsStep` to write to `data.ctrl` each frame. It renders `null` — all it does is read input and drive actuators.

The built-in `<IkController>` is itself built this way. You can use it, swap in your own IK solver, or skip it entirely and write your own controller from scratch.

## Pattern: Simple Keyboard Bindings

For robots where arm control comes from `<IkGizmo />`, the controller only adds extra bindings (gripper, etc.):

```tsx
import { useKeyboardTeleop } from 'mujoco-react';

export function FrankaController() {
  useKeyboardTeleop({
    bindings: {
      v: { actuator: 'gripper', toggle: [0, 255] },
    },
  });
  return null;
}
```

Drop it into your scene as a child of `<MujocoCanvas>`:

```tsx
<MujocoCanvas config={frankaConfig}>
  <SceneRenderer />
  <IkController config={{ siteName: 'tcp', numJoints: 7 }}>
    <IkGizmo />
  </IkController>
  <FrankaController />
</MujocoCanvas>
```

## Pattern: Custom Physics-Step Control

For more complex control (IK solvers, velocity control, state machines), use `useBeforePhysicsStep` to write directly to `data.ctrl` each frame.

### Keyboard State

Read keyboard input via window event listeners and a ref:

```tsx
import { useEffect, useRef } from 'react';
import { useBeforePhysicsStep } from 'mujoco-react';

function MyController() {
  const keys = useRef<Record<string, boolean>>({});

  useEffect(() => {
    const down = (e: KeyboardEvent) => { keys.current[e.code] = true; };
    const up = (e: KeyboardEvent) => { keys.current[e.code] = false; };
    window.addEventListener('keydown', down);
    window.addEventListener('keyup', up);
    return () => {
      window.removeEventListener('keydown', down);
      window.removeEventListener('keyup', up);
    };
  }, []);

  useBeforePhysicsStep((_model, data) => {
    const k = keys.current;
    if (k['KeyW']) data.ctrl[0] += 0.01;
    if (k['KeyS']) data.ctrl[0] -= 0.01;
  });

  return null;
}
```

### Config-Driven Arm Controller

A generic hook that accepts a static config object makes it easy to support multiple robots. Each robot is just a different config — no per-robot logic:

```tsx
interface ArmConfig {
  indices: number[];        // Actuator indices for this arm
  keys: string[];           // Key codes for movement
  initialJoints?: number[]; // Starting joint positions
}

interface ArmControllerConfig {
  numActuators: number;
  arms: ArmConfig[];
  base?: { ... };  // Mobile base drive
  head?: { ... };  // Pan/tilt head
}
```

The hook reads keyboard state and writes to the correct actuator indices each frame:

```tsx
function useArmController(config: ArmControllerConfig) {
  const keys = useRef<Record<string, boolean>>({});

  // ... keyboard listeners ...

  useBeforePhysicsStep((_model, data) => {
    for (const arm of config.arms) {
      // Read keys, solve IK, write to data.ctrl[arm.indices[i]]
    }
  });
}
```

Then each robot controller is just a config:

```tsx
const SO101_CONFIG: ArmControllerConfig = {
  numActuators: 6,
  arms: [{
    indices: [0, 1, 2, 3, 4, 5],
    keys: ['KeyD', 'KeyA', 'KeyW', 'KeyS', 'KeyQ', 'KeyE',
           'KeyR', 'KeyF', 'KeyZ', 'KeyC', 'KeyV'],
    initialJoints: [0.0158, 2.052, 2.1307, -0.0845, 1.5857, -0.3745],
  }],
};

export function SO101Controller() {
  useArmController(SO101_CONFIG);
  return null;
}
```

## Bring Your Own IK

You have three options for IK:

### 1. Use the built-in solver

The default `<IkController>` uses Damped Least-Squares — works for any robot, no tuning needed:

```tsx
<IkController config={{ siteName: 'tcp', numJoints: 7 }}>
  <IkGizmo />
</IkController>
```

### 2. Plug in your own solver

Pass `ikSolveFn` to replace the built-in solver while keeping the gizmo, reset handling, and context:

```tsx
import type { IKSolveFn } from 'mujoco-react';

const myIK: IKSolveFn = (pos, quat, currentQ) => {
  return myAnalyticalSolver(pos, currentQ); // return joint angles or null
};

<IkController config={{ siteName: 'tcp', numJoints: 7, ikSolveFn: myIK }}>
  <IkGizmo />
</IkController>
```

### 3. Skip IkController entirely

Solve IK yourself inside `useBeforePhysicsStep` with full access to the model and data:

```tsx
function MyIKController({ targetRef }) {
  useBeforePhysicsStep((model, data) => {
    const target = targetRef.current;
    if (!target) return;

    const joints = myCustomIKSolve(model, data, target);
    if (joints) {
      for (let i = 0; i < joints.length; i++) data.ctrl[i] = joints[i];
    }
  });
  return null;
}
```

This gives you complete control — use any solver library, any input source, any number of end-effectors.

## Pattern: Reusable Plugins with `createController`

For reusable controllers with typed config and default merging, use the `createController` factory. It handles config merging, display names, and metadata — you focus on the control logic.

```tsx
import { createController, useBeforePhysicsStep } from 'mujoco-react';

// 1. Define your config type
interface MyConfig {
  gain: number;
  actuatorIndex: number;
  frequency?: number;
}

// 2. Write the implementation component
function MyControllerImpl({ config, children }: { config: MyConfig; children?: React.ReactNode }) {
  useBeforePhysicsStep((_model, data) => {
    const freq = config.frequency ?? 1.0;
    data.ctrl[config.actuatorIndex] = config.gain * Math.sin(data.time * freq);
  });
  return <>{children}</>;
}

// 3. Create the controller with the factory
export const MyController = createController<MyConfig>(
  { name: 'MyController', defaultConfig: { gain: 1.0, frequency: 1.0 } },
  MyControllerImpl,
);

// Usage: <MyController config={{ gain: 2.0, actuatorIndex: 0 }} />
```

### `createController` API

```ts
function createController<TConfig>(
  options: { name: string; defaultConfig?: Partial<TConfig> },
  Impl: React.FC<{ config: TConfig; children?: React.ReactNode }>,
): ControllerComponent<TConfig>;
```

The returned component accepts `config` (merged with defaults) and optional `children`. It also exposes static metadata: `MyController.controllerName` and `MyController.defaultConfig`.

### Providing Context to Children

Controllers can provide state to descendants via React context (this is how `IkController` works):

```tsx
const MyContext = createContext<MyContextValue | null>(null);

function MyControllerImpl({ config, children }) {
  const value = useMemo(() => ({ /* state + methods */ }), []);
  return <MyContext.Provider value={value}>{children}</MyContext.Provider>;
}
```

### Listening for Resets

Register a callback to reset your controller state when the simulation resets:

```tsx
function MyControllerImpl({ config, children }) {
  const { resetCallbacks } = useMujocoSim();

  useEffect(() => {
    const cb = () => { /* reset your state */ };
    resetCallbacks.current.add(cb);
    return () => { resetCallbacks.current.delete(cb); };
  }, [resetCallbacks]);

  return <>{children}</>;
}
```

The library's `IkController` is itself built with `createController`, demonstrating all these patterns: context provision, reset handling, `useBeforePhysicsStep` for solving, and `useFrame` for gizmo animation.

## Coexisting with IK Gizmo

When a robot supports both gizmo drag and keyboard control, the controller needs to:

1. **Detect when IK is active** via `useIk({ optional: true })`
2. **Sync state on transition** — when the user switches from gizmo to keyboard, read `data.ctrl` to avoid a position jump
3. **Disable IK** via `ikCtx.setIkEnabled(false)` when taking over

```tsx
import { useIk, useBeforePhysicsStep } from 'mujoco-react';

function MyArmController() {
  const ikCtx = useIk({ optional: true });

  useBeforePhysicsStep((_model, data) => {
    const anyKeyPressed = /* check keyboard state */;

    if (anyKeyPressed && ikCtx?.ikEnabledRef.current) {
      // Sync from current gizmo position
      for (let i = 0; i < arm.indices.length; i++) {
        targetJoints[i] = data.ctrl[arm.indices[i]];
      }
      ikCtx.setIkEnabled(false);
    }

    if (!ikCtx?.ikEnabledRef.current) {
      // Keyboard is in control — solve IK and write ctrl
      for (let i = 0; i < arm.indices.length; i++) {
        data.ctrl[arm.indices[i]] = targetJoints[i];
      }
    }
  });
}
```

The `{ optional: true }` parameter means the hook returns `null` if no `<IkController>` exists in the tree — so the controller works with or without IK.

The gizmo re-enables IK automatically when dragged.

## Composing Controllers in Your Scene

Controllers are just React children. Swap them based on state:

```tsx
<MujocoCanvas config={entry.config}>
  <SceneRenderer />
  {entry.hasIk && showGizmo && (
    <IkController config={{ siteName: 'tcp', numJoints: 7 }}>
      <IkGizmo scale={entry.gizmoScale} />
    </IkController>
  )}
  <DragInteraction />

  {robotKey === 'franka' && <FrankaController />}
  {robotKey === 'so101' && <SO101Controller />}
  {robotKey === 'xlerobot' && <XLeRobotController />}
</MujocoCanvas>
```

## Performance Tips

- Use `for` loops instead of `.forEach` / `.map` in `useBeforePhysicsStep` — it runs every physics tick
- Store keyboard state in a `useRef`, not `useState` — avoids re-renders at 60fps
- Cache actuator IDs once (not every frame) using `findActuatorByName`
- Keep the callback closure stable — avoid creating new functions each render
