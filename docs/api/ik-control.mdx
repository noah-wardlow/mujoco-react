---
title: "IK Control"
description: "Inverse kinematics via the IkController plugin"
icon: "robot"
---

IK is provided by the `<IkController>` plugin — it is not part of the core `MujocoSimAPI`. Access IK methods via the `useIk()` hook from any component inside `<IkController>`.

## Setup

```tsx
import { IkController, IkGizmo, useIk } from 'mujoco-react';

<MujocoCanvas config={config}>
  <SceneRenderer />
  <IkController config={{ siteName: 'tcp', numJoints: 7 }}>
    <IkGizmo />
    <MyIkConsumer />
  </IkController>
</MujocoCanvas>
```

## useIk() Methods

### setIkEnabled(enabled)

Enable or disable the IK solver.

```tsx
const { setIkEnabled } = useIk();
setIkEnabled(true);   // IK writes to ctrl each frame
setIkEnabled(false);  // IK disabled — you control ctrl
```

<Warning>
  When IK is enabled, it overwrites `data.ctrl` for the arm joints inside `useBeforePhysicsStep`. Disable IK when running your own control (policies, teleoperation, etc.).
</Warning>

### moveTarget(pos, duration?)

Animate the IK target (gizmo) to a new position.

```tsx
const { moveTarget } = useIk();
moveTarget(new THREE.Vector3(0.5, 0, 0.3));       // Instant
moveTarget(new THREE.Vector3(0.5, 0, 0.3), 500);  // 500ms animation
```

### syncTargetToSite()

Snap the IK gizmo to the current site position.

```tsx
const { syncTargetToSite } = useIk();
syncTargetToSite();
```

Useful after programmatic joint changes to re-align the gizmo with the actual end-effector.

### solveIK(pos, quat, currentQ)

Run IK solving manually (without the gizmo).

```tsx
const { solveIK } = useIk();
const targetPos = new THREE.Vector3(0.5, 0, 0.3);
const targetQuat = new THREE.Quaternion();
const currentJoints = Array.from(api.getQpos()).slice(0, 7);

const solution = solveIK(targetPos, targetQuat, currentJoints);
if (solution) {
  const qpos = api.getQpos();
  for (let i = 0; i < solution.length; i++) {
    qpos[i] = solution[i];
  }
  api.setQpos(qpos);
}
```

**Returns:** `number[] | null` — joint positions, or null if solver failed.

### getGizmoStats()

Get the current IK gizmo position and orientation.

```tsx
const { getGizmoStats } = useIk();
const stats = getGizmoStats();
if (stats) {
  console.log('Gizmo position:', stats.pos);
  console.log('Gizmo rotation:', stats.rot);
}
```

**Returns:** `{ pos: THREE.Vector3, rot: THREE.Euler } | null`

## Optional Access

For components that may or may not be inside an `<IkController>`, use `{ optional: true }`:

```tsx
const ikCtx = useIk({ optional: true });
// Returns null if no IkController ancestor

if (ikCtx?.ikEnabledRef.current) {
  ikCtx.setIkEnabled(false);
}
```

## Custom IK Solver

Pass `ikSolveFn` to `<IkController>` to replace the built-in solver:

```tsx
import type { IKSolveFn } from 'mujoco-react';

const myIK: IKSolveFn = (pos, quat, currentQ) => {
  const solution = myAnalyticalSolver(pos, currentQ);
  return solution;
};

<IkController config={{ siteName: 'tcp', numJoints: 7, ikSolveFn: myIK }}>
  <IkGizmo />
</IkController>
```

**When to use a custom solver:**

- **Analytical IK** — faster and more reliable for specific robot geometries
- **Learned IK** — neural network solvers trained on your robot
- **External solvers** — calling into WASM-compiled libraries (e.g. KDL, TRAC-IK)
- **Constrained IK** — solvers that enforce joint limits, collision avoidance, or task-space constraints

## Built-in Solver Details

The default solver uses **Damped Least-Squares** (DLS) with finite-difference Jacobian:

- **Max iterations**: 50 per frame (configurable)
- **Damping**: 0.01 (configurable)
- **Position weight**: 1.0
- **Rotation weight**: 0.3
- **Tolerance**: 1e-3
- **Method**: Finite-difference Jacobian + pseudoinverse
